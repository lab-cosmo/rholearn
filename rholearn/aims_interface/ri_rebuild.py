"""
Module for rebuilding fields in FHI-aims from RI coefficients.
"""

import os
from os.path import exists, join
from typing import Callable, List

import numpy as np
from chemfiles import Frame

from rholearn.aims_interface import hpc, io, parser
from rholearn.options import get_options
from rholearn.rholearn import mask
from rholearn.utils import convert, system


def run_ri_rebuild() -> None:
    """
    Runs an RI fit rebuild calculation. If `MASK` settings are specified in
    ``dft_settings``, coefficients of masked atoms are set to zero before rebuilding.
    """

    # Get the DFT and HPC options
    dft_options, hpc_options = _get_options()

    # Get the frames and indices
    frames = system.read_frames_from_xyz(dft_options["XYZ"])
    if dft_options.get("IDX_SUBSET") is not None:
        frame_idxs = dft_options.get("IDX_SUBSET")
    else:
        frame_idxs = list(range(len(frames)))

    # Exclude some structures if specified
    if dft_options["IDX_EXCLUDE"] is not None:
        frame_idxs = [A for A in frame_idxs if A not in dft_options["IDX_EXCLUDE"]]

    frames = [frames[A] for A in frame_idxs]

    # Retype masked atoms for the RI calculation
    if dft_options.get("MASK") is not None:
        frames = mask.retype_frame(
            frames,
            **dft_options["MASK"],
        )

    coefficients = []
    for A, frame in zip(frame_idxs, frames):

        # Load the basis set definition
        lmax, nmax = parser.extract_basis_set_info(frame, dft_options["RI_DIR"](A))

        # Load the RI coefficients generated by the RI fitting procedure straight to
        # TensorMap format
        coeff_numpy = np.loadtxt(
            join(dft_options["RI_DIR"](A), "ri_restart_coeffs.out")
        )

        # As a means of testing the conversion, convert to TensorMap and back
        coeff = convert.coeff_vector_ndarray_to_tensormap(
            frame,
            coeff_vector=coeff_numpy,
            lmax=lmax,
            nmax=nmax,
            structure_idx=A,
            tests=100,
        )

        # Mask and unmask coefficients if applicable - i.e. slice away masked samples
        # then refill with zeros
        if dft_options.get("MASK") is not None:
            coeff = mask.mask_coeff_vector(
                coeff_vector=coeff,
                atom_idxs_to_keep=list(
                    dft_options["MASK"]["get_active_coords"](frame.positions)
                )
                + list(dft_options["MASK"]["get_buffer_coords"](frame.positions)),
                drop_empty_blocks=False,
                backend="numpy",
            )
            coeff = mask.unmask_coeff_vector(
                coeff_vector=coeff,
                frame=frame,
                frame_idxs=A,
                in_keys=coeff.keys,
                properties=[block.properties for block in coeff],
                backend="numpy",
            )

        # Convert back to numpy
        coeff_numpy = convert.coeff_vector_blocks_to_flat(
            frame=frame,
            coeff_vector=coeff,
            lmax=lmax,
            nmax=nmax,
        )

        coefficients.append(coeff_numpy)

    # Now call the rebuild routine
    rebuild_field(
        frame_idxs=frame_idxs,
        frames=frames,
        coefficients=coefficients,
        rebuild_dir=dft_options["REBUILD_DIR"],
        aims_command=dft_options["AIMS_COMMAND"],
        base_settings=dft_options["BASE_AIMS"],
        rebuild_settings=dft_options["REBUILD"],
        cube_settings=dft_options["CUBE"],
        species_defaults=dft_options["SPECIES_DEFAULTS"],
        slurm_params=hpc_options["SLURM_PARAMS"],
        load_modules=hpc_options["LOAD_MODULES"],
        export_vars=hpc_options["EXPORT_VARIABLES"],
    )


def rebuild_field(
    frame_idxs: List[int],
    frames: List[Frame],
    coefficients: List[np.ndarray],
    rebuild_dir: Callable,
    *,
    aims_command: str = None,
    base_settings: dict = None,
    rebuild_settings: dict = None,
    cube_settings: dict = None,
    species_defaults: str,
    slurm_params: dict = None,
    load_modules: List[str] = None,
    export_vars: List[str] = None,
) -> None:
    """
    Takes a list of numpy arrays corresponding to RI coefficients `coefficients` for
    each frame in `frames`. Writes them to `ri_coeffs.in` in each respective
    ``rebuild_dir``, indexed by ``frame_idxs``, then rebuilds the field by calling
    FHI-aims.
    """
    for A, frame, coeff in zip(frame_idxs, frames, coefficients):

        # Make rebuild directory
        if not exists(rebuild_dir(A)):
            os.makedirs(rebuild_dir(A))

        # Write coefficient vector to "ri_coeffs.in"
        np.savetxt(os.path.join(rebuild_dir(A), "ri_restart_coeffs.out"), coeff)

        # Get control parameters
        control_params = io.get_control_parameters_for_frame(
            frame, base_settings, rebuild_settings, cube_settings
        )

        # Write input files
        io.write_geometry(frame, rebuild_dir(A))
        io.write_control(
            frame,
            rebuild_dir(A),
            parameters=control_params,
            species_defaults=species_defaults,
        )

    # Write submission script and run FHI-aims via sbatch array
    fname = f"run-aims-rebuild-{hpc.timestamp()}.sh"
    hpc.write_aims_sbatch_array(
        fname=fname,
        aims_command=aims_command,
        array_idxs=frame_idxs,
        run_dir=rebuild_dir,  # callable to each structure dir
        dm_restart_dir=None,
        load_modules=load_modules,
        export_vars=export_vars,
        slurm_params=slurm_params,
    )
    hpc.run_script(".", f"sbatch {fname}")

    return


def _get_options() -> None:
    """
    Sets the settings globally. Ensures the defaults are set first and then
    overwritten with user settings.
    """
    dft_options = get_options("dft", "rholearn")
    hpc_options = get_options("hpc")

    # Set some extra directories
    dft_options["SCF_DIR"] = lambda frame_idx: join(
        dft_options["DATA_DIR"], "raw", f"{frame_idx}"
    )
    dft_options["RI_DIR"] = lambda frame_idx: join(
        dft_options["DATA_DIR"], "raw", f"{frame_idx}", dft_options["RUN_ID"]
    )
    dft_options["PROCESSED_DIR"] = lambda frame_idx: join(
        dft_options["DATA_DIR"], "processed", f"{frame_idx}", dft_options["RUN_ID"]
    )
    dft_options["REBUILD_DIR"] = lambda frame_idx: join(
        dft_options["DATA_DIR"],
        "raw",
        f"{frame_idx}",
        dft_options["RUN_ID"],
        "rebuild",
    )

    return dft_options, hpc_options
