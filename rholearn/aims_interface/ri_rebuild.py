"""
Module for rebuilding fields in FHI-aims from RI coefficients.
"""

import os
from os.path import exists, join
from typing import Callable, Dict, List, Union

from chemfiles import Frame
import numpy as np

from rholearn import mask
from rholearn.aims_interface import hpc, io, parser
from rholearn.settings.defaults import dft_defaults
from rholearn.utils import convert, system


def run_ri_rebuild(dft_settings: dict, hpc_settings: dict) -> None:
    """
    Runs an RI fit rebuild calculation. If `MASK` settings are specified in
    ``dft_settings``, coefficients of masked atoms are set to zero before rebuilding.
    """

    # Set the DFT settings globally
    _set_settings_globally(dft_settings, hpc_settings)

    # Retype masked atoms for the RI calculation
    frames = system.read_frames_from_xyz(XYZ)
    if globals().get("MASK") is not None:
        frames = mask.retype_masked_atoms(
            frames,
            get_masked_coords=MASK["get_masked_coords"],
        )

    coefficients = []
    for A, frame in zip(FRAME_IDXS, frames):

        # Load the basis set definition
        lmax, nmax = parser.extract_basis_set_info(frame, RI_DIR(A))

        # Load the RI coefficients generated by the RI fitting procedure straight to
        # TensorMap format
        coeff_numpy = np.loadtxt(join(RI_DIR(A), "ri_restart_coeffs.out"))

        # As a means of testing the conversion, convert to TensorMap and back
        coeff = convert.coeff_vector_ndarray_to_tensormap(
            frame,
            coeff_vector=coeff_numpy,
            lmax=lmax,
            nmax=nmax,
            structure_idx=A,
            tests=100,
        )

        # Mask and unmask coefficients if applicable - i.e. slice away masked samples
        # then refill with zeros
        if globals().get("MASK") is not None:
            coeff = mask.mask_coeff_vector(
                coeff_vector=coeff,
                atom_idxs_to_keep=list(MASK["get_active_coords"](frame.positions))
                + list(MASK["get_buffer_coords"](frame.positions)),
                drop_empty_blocks=False,
                backend="numpy",
            )
            coeff = mask.unmask_coeff_vector(
                coeff_vector=coeff,
                frame=frame,
                frame_idxs=A,
                in_keys=coeff.keys,
                properties=[block.properties for block in coeff],
                backend="numpy",
            )

        # Convert back to numpy
        coeff_numpy = convert.coeff_vector_blocks_to_flat(
            frame=frame,
            coeff_vector=coeff,
            lmax=lmax,
            nmax=nmax,
        )

        coefficients.append(coeff_numpy)

    # Now call the rebuild routine
    rebuild_field(
        frame_idxs=FRAME_IDXS,
        frames=frames,
        coefficients=coefficients,
        rebuild_dir=REBUILD_DIR,
        aims_command=AIMS_COMMAND,
        base_settings=BASE_AIMS,
        rebuild_settings=REBUILD,
        cube_settings=CUBE,
        species_defaults=SPECIES_DEFAULTS,
        hpc_settings=HPC,
        slurm_params=SLURM_PARAMS,
    )


def rebuild_field(
    frame_idxs: List[int],
    frames: List[Frame],
    coefficients: List[np.ndarray],
    rebuild_dir: Callable,
    *,
    aims_command: str = None,
    base_settings: dict = None,
    rebuild_settings: dict = None,
    cube_settings: dict = None,
    species_defaults: str,
    hpc_settings: dict = None,
    slurm_params: dict = None,
) -> None:
    """
    Takes a list of numpy arrays corresponding to RI coefficients `coefficients` for
    each frame in `frames`. Writes them to `ri_coeffs.in` in each respective
    ``rebuild_dir``, indexed by ``frame_idxs``, then rebuilds the field by calling
    FHI-aims.
    """

    for A, frame, coeff in zip(frame_idxs, frames, coefficients):

        # Make rebuild directory
        if not exists(rebuild_dir(A)):
            os.makedirs(rebuild_dir(A))

        # Write coefficient vector to "ri_coeffs.in"
        np.savetxt(os.path.join(rebuild_dir(A), "ri_restart_coeffs.out"), coeff)

        # Get control parameters
        control_params = io.get_control_parameters_for_frame(
            frame, base_settings, rebuild_settings, cube_settings
        )

        # Write input files
        io.write_geometry(frame, rebuild_dir(A))
        io.write_control(
            frame,
            rebuild_dir(A),
            parameters=control_params,
            species_defaults=species_defaults,
        )

    # Write submission script and run FHI-aims via sbatch array
    fname = "run-aims-rebuild.sh"
    hpc.write_aims_sbatch_array(
        fname=fname,
        aims_command=aims_command,
        array_idxs=frame_idxs,
        run_dir=rebuild_dir,  # callable to each structure dir
        dm_restart_dir=None,
        load_modules=hpc_settings["load_modules"],
        export_vars=hpc_settings["export_vars"],
        slurm_params=slurm_params,
    )
    hpc.run_script(".", f"sbatch {fname}")

    return


def _set_settings_globally(dft_settings: dict, hpc_settings: dict) -> None:
    """
    Sets the settings globally. Ensures the defaults are set first and then
    overwritten with user settings.
    """
    # Update DFT and ML defaults with user settings
    dft_settings_ = dft_defaults.DFT_DEFAULTS
    dft_settings_.update(dft_settings)

    # Set them globally
    for settings_dict in [dft_settings_, hpc_settings]:
        for key, value in settings_dict.items():
            globals()[key] = value


    # Set some directories
    globals()["SCF_DIR"] = lambda frame_idx: join(DATA_DIR, "raw", f"{frame_idx}")
    globals()["RI_DIR"] = lambda frame_idx: join(DATA_DIR, "raw", f"{frame_idx}", RI_FIT_ID)
    globals()["REBUILD_DIR"] = lambda frame_idx: join(DATA_DIR, "raw", f"{frame_idx}", RI_FIT_ID, "rebuild")
    globals()["PROCESSED_DIR"] = lambda frame_idx: join(DATA_DIR, "processed", f"{frame_idx}", RI_FIT_ID)
